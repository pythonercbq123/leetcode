```
单调栈思路
```

```
# 求左边第一个小于arr[i]的元素： 从左到右遍历数组并维护一个单调递增的栈，遍历当前数组arr[i], 遍历当前元素arr[i], 如果遇到当前栈顶的元素大于等于arr[i],将其弹出，直到栈顶的元素小于arr[i], 那么栈顶的元素就是第一个小于arr[i]的元素arr[j],此时left[i] = i - j

# 求右边第一个小于等于arr[i]的元素：从右到左遍历数组， 维护一个单调递增的栈，遍历当前元素arr[i],如果遇到当前栈顶的元素大于arr[i], 将其弹出， 直至栈顶的元素小于等于arr[i], 那么栈顶的元素就是右边第一个小于等于arr[i]的元素arr[k], 此时right[i] = k - i

# 此时连续数组arr[j] ~ arr[k]的最小元素为arr[i], 以arr[i]为最小元素的连续子序列的数量为(i-j)(k-i)
```

